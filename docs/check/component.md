# Компоненты

1. Компоненты решают задачу представления - как и где отобразить данные. В основном содержат вёрстку.
2. Подписываются на пользовательские события (клик мышкой, ввод с клавиатуры...),
но зачастую не обрабатывают их, а вызывают соответствующие функции обратного вызова из `props`.
3. Все данные компоненту передаются через `props`, самостоятельно компонент ничего не узнает, он глупый.
4. Компонент глупый, но может иметь своё состояние для реализации сложной логики отображения (рендера).
5. Компоненты создаются в директории `/components`.
6. Группируются в поддиректории, чтобы проще ориентироваться в них.
7. Не используется реэкспорт списка компонентов. Каждый компонент импортируется отдельной инструкцией с указанием полного пути.
8. В директории компонента могут находиться дополнительные ресурсы, импортируемые самим компонентом - стили, картинки, утилиты и др.
9. Компонент решает одну конкретную задачу. Для сложных задач используется композиция из нескольких компонент.
10. Если составные части компонента ввиде отдельных компонент повторно нигде не используются, то их разместить в поддиректории основого компонента.
11. Признак толстого компонента - большой перечень свойств в `props` или вёрстка на сотню строк.
12. Обязательно описывать все получаемые компонентом свойства и их значения по умолчанию в `propsTypes` и `defaultProps`.
13. Компонент описывается именованной функцией в CamelCase: `function ComponentName(){}`.
14. Компоненты на классах используются в исключительных случаях. 
15. Используются [Хуки](https://ru.reactjs.org/docs/hooks-overview.html).
16. Каждый компонент в отдельной директории, имя директории соответствует названию компонента в нижнем регистре через дефис. `ComponentName()` → `/component-name`
17. Функция компонента оборачивается в [`React.memo()`](https://ru.reactjs.org/docs/react-api.html#reactmemo), чтобы повторно не исполнялась при тех же `props`. Если на классах, то используется PureComponent.

## Типовая струткура компонента

```
component-name 
├── index.js
└── style.less
```

*Пример кнопки с функцией обратного вызова на клик*
```js
function Button(props) {
  // Все колбэки группируются в объекте callbacks - ниже по коду знаем от куда функция
  const callbacks = {
    onClick: useCallback(e => {
      if (props.onClick) {
        e.preventDefault();
        props.onClick();
      }
    }, [props.onClick]),
  };
  // props не разворачивается на отдельные переменные, чтобы сразу и однозначно понимать от куда берутся значения
  return (
      <button
        type={props.type}
        className={cn(`Button`, themes('Button', props.theme))}
        title={props.title}
        onClick={callbacks.onClick}
        disabled={props.disabled}
      >
        {props.children}
      </button>
    );
}

Button.propTypes = {
  children: PropTypes.node,
  onClick: PropTypes.func,
  type: PropTypes.string,
  title: PropTypes.string,
  theme: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),
  disabled: PropTypes.bool,
};

Button.defaultProps = {
  type: 'button',
  disabled: false,
  theme: '',
};

export default React.memo(Button);
```
